#### 如何高效学习 要点
###### 一、3分看视频，7分练习
1.5倍数播放，不懂得反复看，直到理解为止。类似你看完keep视频之后，你得自己多多练习。

###### 二、遵循五毒神掌
遵循五毒神掌，否则算法训练营会前功尽弃!敢于死记硬背代码的模板。当然要理解。你即使有些题目来不及做，你要保证之前做的题目要达到5遍。重要的是过遍数，而不是每次花很长时间。

###### 三、最好的学习方式
十多年算法和训练需求以及当面试官总结的经验，这是最好的学习方式，也是各种运动的职业化训练采用的方式，他其实就是一种刻意练习！！！

#### 预习 第1 课 | 数据结构与算法总览 要点

##### 一、职业训练
拆分知识点、刻意练习、寻求反馈(主动反馈是自己去看好的题解、高票代码，被动反馈是进行别人进行code review)
脑图+刻意练习+过遍数。练好基本功，成为你的条件反射。

##### 二、切题4件套
1)5-10分钟看题理解。比如多和面试官沟通,是这样的吗!!!确保自己理解没问题。
2)把所有可能的解法都过一遍!!!同时比较时间和空间复杂度。从中找出最优的解法。优化的思想：升维，空间换时间。把思路整理出来(1.2.3)->国际站Most Votes(你学到了最可贵的东西，那是全人类的结晶。国内的不好)+相应极客视频+花花视频+github+bilibili+youtobe，从最土的到高级解法，分析一下时间和空间复杂度。
3)多写几遍，把各种思路都写一下，在IDE上。背诵默写代码，先把它背诵和默写之后，100%都是可以理解的。算法是理解和运用即可，而不是发明创造。默写背诵、熟练，大家一定要写得滚瓜烂熟，也就是肌肉记忆，睡觉的时候也可以想想
4)多用几个测试用例，放特征case，这样有始有终。

##### 三、五步刷题法(五毒神掌)
第一遍:自己闭卷自己写。自己在一个空白的文件上自己把多种代码敲出来。直到通过。不同解法比较他们的执行时间，同一解法的话，如果实行时间过长，看看怎么优化下。直到不同解法都能通过，而且执行时间是相对较优的。比如领先90%就不错了。领先80%也可以。看时间，超过90%或者80%也是可以，内存不用看
第二遍：过了24小时之后，再重新做下昨天做过的题目。对不熟练的题的话，进行专项训练。
第三遍：过了一周之后，再重新做做过的题目。对不熟练的题的话，再进行专项训练。
第四遍：过了二周之后，在再重新做做过的题目。对不熟练的题的话，再进行专项训练。到这时候，基本上就对这些题目比较熟练了。
第五遍：面试前2星期进行恢复性训练的话，把之前做过的题目再做一遍。

##### 四、做题最大的误区!做题最大的误区!做题最大的误区!
只做一遍。一定要反复练习，直到变成肌肉记忆，一看到题目就知道方法1/2/3是什么，然后马上把代码模板就可以写出来。在这个前提下，你才有出路。

##### 五、总结
学习本课程，在正确刷题的前提下，可以达到职业顶尖水平，可以去互联网面试，不再胆怯，而且会拿到一线互联网的OFFER。在此基础上，好好练习，可以有300+的积累量。主体思想和高级算法模板都练习好了，再过遍数，提高水平是sure的事。最原始的也是最有效的

##### 六、PS
最原始的学习方法|如今覃超老师推荐的的方法|实践感觉|类比城北伯庸说的(惊人的相似)|
-|-|-|-|
老师帮忙画重点大纲|对应脑图(没人给你画重点了，你得请教找人问并自己画)|没有脑图，就没有方向，自己会混乱，反之有方向，自己有全局意识|必要技能|
老师帮忙给出答案|理解大佬的解法(没有直接给你答案了，你得自己去找)|不好好找的话，解法很差，自己的思想也得不到提升，反之，获得世界先进生产力|必要理论|
老师帮忙给出解释|总结思路(没有人帮你总结了，你得去找，总结出自己的)|不好好总结的话，抓不住核心，遇到一样的也做不出来，反之，抓住核心，抓住问题的关键|必要理论的解释(第一步刷题还没开始呢，你是在过题啊，这只是在课堂上抄老师的题解和思路，练习还没开始呢,所以平时得抓紧背诵训练)|
老师要求你背诵|背诵(没人让你背诵了，你得自己背)|不背诵的话，效果非常差劲，还是没办法展开工作，反之轻轻松松开展工作|练习必不可少的一步，必须熟练才行，否则那边缺一点，这边缺一点就完了
老师让你练习|练习(没有人催你练习了，你得找人练)|不好好练的话，上面都白瞎，没有实践经验，漏洞百出，反之，具有成就感，下一次会更有动力，进入正循环|大量练习，变成肌肉记忆|
#### 预习 第2课 | 训练准备和复杂度分析之训练准备 要点

##### 一、训练环境设置、编码技巧和Code Style 
###### 1.电脑设置
使用google搜索，科学上网，和徐总沟通了一个好用的VPN:一支红杏

###### 2.必看高票题解
去掉-cn就是国际站:leetcode.com
选most vote，看最高票的回答和最高票的答案，学习国际先进生产力，把前3个回答看好就很不错了(在5遍刷题法第三遍和第四遍的时候，会学到很多东西

###### 3.VScode快捷键
选中整行粘贴复制一定搞地特别熟练
|快捷键|操作|
-|-|
|ctrl+k,ctrl+s|快捷键指南|
|Home/End|行头行尾移动
|ctrl+left/right|光标按单词进行移动
|ctrl+d|选中单词
|ctrl+delete|删除光标右边单词
|ctrl+l|选中整行
|shift+delete|删除整行

IDE自动补全功能(函数自动补全？)
top tips for vscode
[宇宙最强vscode教程(基础篇)](https://segmentfault.com/a/1190000017949680)
刻意练习，逼自己一把，不断地磨炼自己，少做无用功

###### 4.code style
![code style代码示例](https://upload-images.jianshu.io/upload_images/10106455-1148da47f0f107ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
看看google style 上的代码示例就行了 ，这样给面试官的印象就不一样了
if 后面一定要有空格
左括号前面一定要有空格，同时左括号不要另起一行
for 循环后面一定要有空格
所有的括号和关键字前后都要有空格
运算符前面都要有空格

###### 5.自顶向下的编程方式
![自顶向下的编程示例](https://upload-images.jianshu.io/upload_images/10106455-9482ef5f59ef0ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
自顶向下的编程方式：先思考大层次的逻辑，而不要纠结他的细节
高层次主干逻辑，用IDE帮你生成函数代码，再专注写枝干代码
后续再进行优化

###### 6、要成为职业顶尖水平
![13.62% 具有很大的优化空间](https://upload-images.jianshu.io/upload_images/10106455-438ecf63516087d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 一、训练环境设置、编码技巧和Code Style 
###### 1.电脑设置
使用google搜索，科学上网，和徐总沟通了一个好用的VPN:一支红杏

###### 2.必看高票题解
去掉-cn就是国际站:leetcode.com
选most vote，看最高票的回答和最高票的答案，学习国际先进生产力，把前3个回答看好就很不错了(在5遍刷题法第三遍和第四遍的时候，会学到很多东西

###### 3.VScode快捷键
选中整行粘贴复制一定搞地特别熟练
|快捷键|操作|
-|-|
|ctrl+k,ctrl+s|快捷键指南|
|Home/End|行头行尾移动
|ctrl+left/right|光标按单词进行移动
|ctrl+d|选中单词
|ctrl+delete|删除光标右边单词
|ctrl+l|选中整行
|shift+delete|删除整行

IDE自动补全功能(函数自动补全？)
top tips for vscode
[宇宙最强vscode教程(基础篇)](https://segmentfault.com/a/1190000017949680)
刻意练习，逼自己一把，不断地磨炼自己，少做无用功

###### 4.code style
![code style代码示例](https://upload-images.jianshu.io/upload_images/10106455-1148da47f0f107ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
看看google style 上的代码示例就行了 ，这样给面试官的印象就不一样了
if 后面一定要有空格
左括号前面一定要有空格，同时左括号不要另起一行
for 循环后面一定要有空格
所有的括号和关键字前后都要有空格
运算符前面都要有空格

###### 5.自顶向下的编程方式
![自顶向下的编程示例](https://upload-images.jianshu.io/upload_images/10106455-9482ef5f59ef0ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
自顶向下的编程方式：先思考大层次的逻辑，而不要纠结他的细节
高层次主干逻辑，用IDE帮你生成函数代码，再专注写枝干代码
后续再进行优化

###### 6、要成为职业顶尖水平
![13.62% 具有很大的优化空间](https://upload-images.jianshu.io/upload_images/10106455-438ecf63516087d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 预习 第2课 | 训练准备和复杂度分析之复杂度分析 要点
##### 一、总说
通过看程序辨别时间和空间复杂度。养成习惯，写完能够分析这个程序的时间和空间复杂度。能够用最优的时间和空间复杂度完成程序，基本上是一个顶尖职业选手的必备素养。
刷题4件套!多个想法，比较他们的时间复杂度，选择最优的，内存的话，用得最少的话最好...

##### 一、时间复杂度
###### 1.时间复杂度为O(logn)分析
![](https://upload-images.jianshu.io/upload_images/10106455-9e246498ea27b561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
O(log(n)):n = 4,循环2次，log2n，所以时间复杂度为O(log(n))
O(k^n):如下

###### 2.递归的时间复杂度
![](https://upload-images.jianshu.io/upload_images/10106455-d160294d645b9fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-cb71d88b1827c59d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
递归的执行顺序使用树形进行分析看算多少次
第二层4个节点，第三层是8个节点，按指数级递增的，最后一层的化，那就是2^n，大概这么个数量级的节点。最后执行次数的话，就编程指数级了。
还存在重复的节点。一定不能这么写，用缓存或者循环写。

###### 3.要记住的主定理(解决所有递归函数，怎么计算时间复杂度)
![要记住的主定理](https://upload-images.jianshu.io/upload_images/10106455-46da4a7c1eb9cc87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
2分查找(O(logn))
2叉树遍历(O(n))：每个节点访问一次且只访问一次,n代表2叉树里的节点总数
排好序2维矩阵二分查找(O(n))
归并排序(O(nlogn))
![](https://upload-images.jianshu.io/upload_images/10106455-28081b2a5ccd8b0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
二叉树遍历(O(n))：每个节点访问一次且只访问一次,n代表2叉树里的节点总数
图的遍历(O(n))每个节点访问一次且只访问一次,n代表图里的节点总数
搜索算法：DFS、BFS时间复杂度(O(n))
二分查找：(O(logn))

##### 二、空间复杂度
![](https://upload-images.jianshu.io/upload_images/10106455-335ddbb37a962b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
######1.数组的长度
代码里开了数组，数组的长度基本上就是你的空间复杂度，一维组数O(n)，二维数组(O(n^2))

###### 2.递归的深度
(1)递归最深的深度就是空间复杂度的最大值
![](https://upload-images.jianshu.io/upload_images/10106455-6ef30b75c9311ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
(2)避免重复计算时间复杂度O(n)。开了数组，所以是O(n)
![](https://upload-images.jianshu.io/upload_images/10106455-a61fc6e799c25922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
(3)递归不需要存所有的状态，用2个变量不断的递推
![](https://upload-images.jianshu.io/upload_images/10106455-7ac3df554624cfe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
###### 3.递归中有数组，算2者的max

#### 第一周 第3课 | 数组、链表、跳表 要点

##### 一、数组、链表和跳表的基本实现和特性
###### 1.数组
int a[100]
![](https://upload-images.jianshu.io/upload_images/10106455-b433aaf68f2854d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###### 2.链表
![](https://upload-images.jianshu.io/upload_images/10106455-dcaedf1696668f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
prepend：从头结点增加
append：从尾结点增加

###### 3.跳表(不会让你手写，主要理解和看文章为主)

#### 第一周 第4节 栈、队列、优先队列和双端队列 要点
##### 一、stack queue deque
stack查询的时间复杂度是O(n)，因为元素没有任何顺序可言
queue查询的时间复杂度是O(n)，因为元素没有任何顺序可言
deque双端队列，头和尾都可以进行元素的添加和删除，查询的时间复杂度是O(n)，因为元素没有任何顺序可言

熟悉他们的API(TODO)
他们是用vector还是list实现的？(TODO）

##### 二、priority queue
priority queue优先队列,高级数据结构
取出O(logN)按照元素的优先级取出，取出变慢了。(如果是queue的话，你得找到O(n)再取出O(1))不是先进先出或者先进后出，而是按照元素的优先级取出。类似VIP会员。
底层具体实现的数据结构较为多样和复杂：可用用heap(堆，他也是多种实现的，不一定是二叉树实现的堆)、bst(二叉搜索树)等。



学习笔记
#####1. 哈希表、映射、集合的实现与特性
set/map 查询O(1)
hash table 哈希表
hash function 哈希函数 
hash collisions 哈希碰撞 
完美哈希

优先队列 红黑树 AVL树
STL库已经实现好了，不需要大家手写，要掌握使用方式，API
查询 hash table C++
hash table 查询添加删除都是O(1)
![](https://upload-images.jianshu.io/upload_images/10106455-8493280c29bf2f6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

工程上不使用哈希表，哈希表抽象出来的就是map和set(unordered_map/unordered_set)
map/set使用treeset,都是用红黑树来实现的，那么查询就是O(logN)(map/set)
![](https://upload-images.jianshu.io/upload_images/10106455-303a20b8546c44a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-42e62f74dc987737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 树、二叉树、二叉搜索树的实现和特性  要点
链表查询时间复杂O(n)
要加速就要升维度，那就变成树了
树和图最大的差别就是看有没有环 

##### 链表就是特殊化的树
##### 树就是特殊化的图，没有环的图就是树

树的遍历，前中后
拥抱递归
#### 第二周 第5课 | 哈希表、映射、集合 要点
##### 二叉搜索树
左子树的所有节点的值均小于他的根节点的值
右子树的所有节点的值均大于他的根节点的值
![](https://upload-images.jianshu.io/upload_images/10106455-7c305e7f8e3be36f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-b6b8e2a160fecf04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
树的遍历，因为是无序，所以是O(n)
二叉树要删除节点的话，如果删除的不是根节点，那么拿比他大或小的的最接近的来做垫背，一般取第一个大于他的节点
极端情况下，如下就变成一个链表，那么查询的复杂度就变成O(n)
![](https://upload-images.jianshu.io/upload_images/10106455-5ddd368eb742b3e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-d85afd30532d401c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 把递归遍历记下来，变成肌肉记忆。
递归和动态规划难度比较大，学习比较陡峭
递归和循环效率都一样，不要把递归写残了，比如斐波那契数列
##### 二叉树各种遍历的迭代，看那个题解，都是用stack模拟操作!!!!!!统一解法!!!

#### 第二周 第6课 |  树、堆、图 要点
##### 堆和二叉堆的实现和特性
![](https://upload-images.jianshu.io/upload_images/10106455-4e11b693432ee1ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
数据结构怎么实现，堆的实现有很多种，比如二叉堆等，二叉堆只是相对比较容易实现，但时间复杂度刚刚及格
![](https://upload-images.jianshu.io/upload_images/10106455-a9d1b9b024661e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-748519cda2c14241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
|完全二叉树|满二叉树|
-|-|
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。|除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。|
如果用二叉搜索树实现堆的化，那么在find_min是O(logN)的。时间复杂度不合格。
![](https://upload-images.jianshu.io/upload_images/10106455-a3763ffbfc0e7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-ebfbcb22736fb3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-e0cbec880154deff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/10106455-a3775f57b4096e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
##### 记住二叉堆的性质
![](https://upload-images.jianshu.io/upload_images/10106455-c8e0d92a00eb3f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-6b980b46b02d9779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/10106455-09e9bd29bcd303ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/10106455-c9da21e22537f05e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
优先队列是用堆来实现的，具体是用什么堆，有很多种，他是一个抽象的数据结构。二叉堆是一种常见且简单的实现，但是并不是最优的实现。

##### 3. 图的实现和特性
面试算法的话，基本上很少考图相关的东西
无/有向无/有权图
DFS和BFS这是面试经常考的，一般在树里考
![](https://upload-images.jianshu.io/upload_images/10106455-c12271f462d27649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![递归是怎样的TODO](https://upload-images.jianshu.io/upload_images/10106455-4bd79f474c64e049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 代码模板一定要背诵下来！！！！一看到DFS、BFS就可以把模板咔咔咔写出来。变成条件反射，不要再花5分钟思考怎么写。然后再纸上慢慢调节，这样是不能接受的。
图用邻接矩阵/邻接表表示，邻接矩阵是什么
![临接矩阵是对称阵](https://upload-images.jianshu.io/upload_images/10106455-1032615d1275580a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-28ba0bc5c2462c40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-f998371c08699eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 泛型递归、树的递归 要点
![](https://upload-images.jianshu.io/upload_images/10106455-cc87c74cbb9a2659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-c174e39619f2564e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-22df1c0017089988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
抵制人肉递归!!!!!!
盗梦空间：把东西带进去，再把改变的东西带出来。归去来兮的感觉。
#### 分治 回溯 要点
分治回溯不要去百度，就是递归
分治drill down后加了个merge subresult，把子结果进行合并
回溯找可能的解。
和递归一样都是同一个模板。


学习笔记

第四周 第9课 深度优先和广度优先搜索
根据访问次序的不一样，你可以使用BFS和DFS。
因为程序能帮你维护一个栈，所以DFS你可以用递归。而BFS，程序没办法模拟一个queue，所以BFS的话，只能用迭代方法。
#####DFS递归模板

![](https://upload-images.jianshu.io/upload_images/10106455-cc33ee8f27372793.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-e85490fe321c5f8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#####非递归模板，一定要背的滚瓜烂熟(栈)
![](https://upload-images.jianshu.io/upload_images/10106455-50b44332b5aa8885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#####BFS(队列)
水滴扩展
![](https://upload-images.jianshu.io/upload_images/10106455-b1acf2dff4f11d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
你只要记住就行了。
第四周 第10课 贪心算法
![](https://upload-images.jianshu.io/upload_images/10106455-7eac4a2eacc2139f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
零钱兑换

面试和生活中很少用贪心！！！


第四周 第11课 二分查找
必须进行肌肉记忆
![](https://upload-images.jianshu.io/upload_images/10106455-6f0ffc94cec71c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-697d0ae3356440c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
代码写熟了，不要只看懂，不然会很多bug
自顶向下的编程思想



学习笔记
![](https://upload-images.jianshu.io/upload_images/10106455-eeff836259be9e71.png?imageMogr2/auto-·orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-528b7eef3b06192b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](https://upload-images.jianshu.io/upload_images/10106455-0a254958e25daae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**动态递推**，不淘汰次优解就变成了傻递归，时间复杂度就很高，所以必须淘汰。
![](https://upload-images.jianshu.io/upload_images/10106455-7a4c124a62c95fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
把细节都背诵下来再反复，化繁为简。
![](https://upload-images.jianshu.io/upload_images/10106455-d9114a14b04d935b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
把题目练会就行了。
最字。
a.重复性(分治)
b.定义状态数组
c.DP方程

多练，面试中写出最简单的形式，这样简洁漂亮，你的面试成绩也是最好的。
**至顶向下和至底向上**。


coin change和爬楼梯类似。
![](https://upload-images.jianshu.io/upload_images/10106455-f2330a7d47d749f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1.保底，递归，指数
2.BFS
3.DP
1) sub problems
2) DP array
3) DP 方程

如果是上三阶楼梯，f(n) = f(n - 1) + f(n - 2) + f(n - 2)
![](https://upload-images.jianshu.io/upload_images/10106455-998733ec587d2916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**团灭股票问题**
编辑距离，重点













